<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Buzzer</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = { darkMode: 'class' };
  </script>
  <script src="https://unpkg.com/@supabase/supabase-js"></script>
  <style>
    input, select, textarea {
      background-color: white;
      color: black;
    }
    ::placeholder {
      color: #6b7280;
    }
    .dark input,
    .dark select,
    .dark textarea {
      background-color: #374151;
      color: white;
    }
    .dark ::placeholder {
      color: #9ca3af;
    }
  </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen bg-green-100 text-green-900 font-sans space-y-6 px-4 dark:bg-gray-900 dark:text-white">
  <div class="fixed top-4 right-4 z-50">
    <button onclick="toggleDarkMode()" class="bg-gray-300 dark:bg-gray-700 text-black dark:text-white px-4 py-2 rounded shadow">
      🌙 / ☀️
    </button>
  </div>
  <h1 class="text-3xl font-bold mt-6 sm:mt-8">🔔 Buzzer</h1>
  <audio id="buzz-sound" src="buzz.wav" preload="auto"></audio>

  <p id="status" class="text-xl font-semibold"></p>
  <p id="online-info" class="text-md font-medium"></p>

  <button id="buzzer-btn" class="w-full sm:w-auto text-3xl sm:text-4xl px-8 sm:px-12 py-8 sm:py-10 bg-green-600 text-white rounded-full shadow-xl hover:bg-green-700 disabled:opacity-50 transition-all duration-300">
    🚨 BUZZERN
  </button>

  <!-- Admin Actions -->
  <div id="admin-actions" class="hidden space-x-4 mt-6">
    <button id="plus-btn" class="bg-blue-600 text-white px-4 py-2 rounded shadow hover:bg-blue-700">+1 Punkt</button>
    <button id="minus-btn" class="bg-yellow-600 text-white px-4 py-2 rounded shadow hover:bg-yellow-700">-1 Punkt</button>
    <button id="pass-btn" class="bg-gray-600 text-white px-4 py-2 rounded shadow hover:bg-gray-700">Pass</button>
  </div>

  <!-- Rundensteuerung -->
  <div id="round-controls" class="hidden mt-4 text-center">
    <button id="start-round-btn" class="bg-purple-600 text-white px-4 py-2 rounded shadow hover:bg-purple-700">Runde starten</button>
  </div>

  <!-- Anmelden -->
  <div id="signup-container" class="hidden mt-4 text-center space-y-2">
    <p id="bet-info" class="text-sm"></p>
    <button id="signup-btn" class="bg-green-600 text-white px-4 py-2 rounded shadow hover:bg-green-700">Anmelden</button>
  </div>

  <!-- Rundeninfo -->
  <div id="round-info" class="hidden mt-2 text-center space-y-1 text-sm">
    <p id="signup-timer"></p>
    <div id="participant-list" class="text-xs"></div>
  </div>

  <!-- Ergebnis -->
  <div id="result-display" class="hidden mt-6 bg-white dark:bg-gray-800 p-4 rounded shadow text-center space-y-2">
    <h3 class="text-lg font-bold">Runde beendet</h3>
    <p id="winner-name"></p>
    <p id="prize-info"></p>
    <div id="balance-list" class="text-sm space-y-1"></div>
  </div>

  <!-- Dialog Runde starten -->
  <div id="start-round-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
    <div class="bg-white dark:bg-gray-700 p-6 rounded shadow-lg space-y-4">
      <h3 class="text-lg font-bold">Neue Runde</h3>
      <label class="block">Einsatz:
        <select id="round-bet" class="border p-2 rounded w-full mt-1">
          <option value="0.5">0,50 €</option>
          <option value="1">1,00 €</option>
          <option value="2">2,00 €</option>
        </select>
      </label>
      <label class="block">Punktelimit:
        <input id="round-limit" type="number" min="1" value="5" class="border p-2 rounded w-full mt-1">
      </label>
      <div class="text-right space-x-2">
        <button id="cancel-round-btn" class="bg-gray-500 text-white px-3 py-1 rounded">Abbrechen</button>
        <button id="confirm-round-btn" class="bg-green-600 text-white px-3 py-1 rounded">Starten</button>
      </div>
    </div>
  </div>

  <!-- Punktestand-Tabelle -->
  <div id="scoreboard" class="w-full max-w-xs sm:max-w-md mt-8 bg-white shadow rounded p-4 text-sm sm:text-base overflow-x-auto dark:bg-gray-800">
    <h2 class="text-lg sm:text-xl font-bold mb-4 text-center">🏆 Punktestand</h2>
    <table class="w-full table-auto text-left">
      <thead>
        <tr>
          <th class="px-2 py-1 border-b">Name</th>
          <th class="px-2 py-1 border-b text-right">Punkte</th>
        </tr>
      </thead>
      <tbody id="scoreboard-body">
        <!-- Dynamisch befüllt -->
      </tbody>
    </table>
  </div>

  <!-- Aktionen für Punktetabelle -->
  <div id="score-actions" class="hidden mt-4 text-center">
    <button id="reset-scores-btn" class="bg-red-600 text-white px-4 py-2 rounded shadow hover:bg-red-700">Punkte zurücksetzen</button>
  </div>

  <div class="text-center mt-8 mb-8">
    <a href="dashboard.html" class="inline-block bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-full shadow">
      ⬅️ Zurück zum Dashboard
    </a>
  </div>

  <script>
    function toggleDarkMode() {
      const isDark = document.documentElement.classList.toggle('dark');
      localStorage.setItem('darkMode', isDark ? 'true' : 'false');
    }
    if (localStorage.getItem('darkMode') === 'true') {
      document.documentElement.classList.add('dark');
    }

    const SUPABASE_URL = 'https://izkuiqjhzeeirmcikbef.supabase.co';
    const ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Iml6a3VpcWpoemVlaXJtY2lrYmVmIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDg4MDAwOTQsImV4cCI6MjA2NDM3NjA5NH0.mPu0jQYnt0uGoLgehNFDHZprEcmrzGJ667D31sLSbj0';
    const SERVICE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Iml6a3VpcWpoemVlaXJtY2lrYmVmIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc0ODgwMDA5NCwiZXhwIjoyMDY0Mzc2MDk0fQ.yF2-AKGKcHFNpkIt-bg-YMhWjjLK74cLw6t3VfjDl8w';

    const supabase = window.supabase.createClient(SUPABASE_URL, ANON_KEY);
    const adminClient = window.supabase.createClient(SUPABASE_URL, SERVICE_KEY);

    const buzzerBtn = document.getElementById("buzzer-btn");
    const status = document.getElementById("status");
    const onlineInfo = document.getElementById("online-info");
    const adminActions = document.getElementById("admin-actions");
    const plusBtn = document.getElementById("plus-btn");
    const minusBtn = document.getElementById("minus-btn");
    const passBtn = document.getElementById("pass-btn");
    const resetScoresBtn = document.getElementById("reset-scores-btn");
    const scoreActions = document.getElementById("score-actions");
    const roundControls = document.getElementById("round-controls");
    const startRoundBtn = document.getElementById("start-round-btn");
    const signupContainer = document.getElementById("signup-container");
    const betInfo = document.getElementById("bet-info");
    const signupBtn = document.getElementById("signup-btn");
    const roundInfo = document.getElementById("round-info");
    const signupTimer = document.getElementById("signup-timer");
    const participantList = document.getElementById("participant-list");
    const resultDisplay = document.getElementById("result-display");
    const winnerNameEl = document.getElementById("winner-name");
    const prizeInfoEl = document.getElementById("prize-info");
    const balanceList = document.getElementById("balance-list");
    const startRoundModal = document.getElementById("start-round-modal");
    const roundBet = document.getElementById("round-bet");
    const roundLimit = document.getElementById("round-limit");
    const cancelRoundBtn = document.getElementById("cancel-round-btn");
    const confirmRoundBtn = document.getElementById("confirm-round-btn");

    function parseTime(ts) {
      return new Date(ts.endsWith('Z') ? ts : ts + 'Z');
    }

    let activeRound = null;
    let registrationInterval = null;
    let signedUp = false;
    let lastResult = null;

    let currentUser = null;
    let currentBuzz = null;
    let lastBuzzTimestamp = null;

    async function checkUser() {
      const { data: auth, error } = await supabase.auth.getUser();
      if (error || !auth?.user) {
        return location.href = "index.html";
      }
      currentUser = auth.user;

      const { data: profile } = await supabase
        .from("users")
        .select("role, name")
        .eq("id", currentUser.id)
        .single();

      if (!profile) return;

      currentUser.name = profile.name;
      currentUser.role = profile.role;

      if (currentUser.role === 'admin') {
        scoreActions.classList.remove("hidden");
      }
    }

    async function markOnline() {
      const now = new Date().toISOString();
      await supabase.from("user_sessions").upsert({
        user_id: currentUser.id,
        username: currentUser.name,
        last_active: now,
        online: true
      }, { onConflict: ["user_id"] });
    }

    async function markOffline() {
      await supabase.from("user_sessions")
        .update({ online: false })
        .eq("user_id", currentUser.id);
    }

    async function showOnlineUsers() {
      const threshold = new Date(Date.now() - 2 * 60 * 1000).toISOString();
      const { data, error } = await supabase
        .from("user_sessions")
        .select("username, last_active")
        .eq("online", true)
        .gt("last_active", threshold);

      if (!error) {
        const active = data || [];
        const count = active.length;
        const names = active.map(u => u.username).join(", ");
        onlineInfo.textContent = `🟢 Online (${count}): ${names}`;
      }
    }

    async function getActiveBuzz() {
      const { data, error } = await supabase
        .from("buzzer_state")
        .select("*")
        .eq("active", true)
        .order("timestamp", { ascending: true })
        .limit(1)
        .single();

      return error ? null : data;
    }

    async function refreshStatus() {
      const previousTimestamp = lastBuzzTimestamp;
      currentBuzz = await getActiveBuzz();

      if (currentBuzz) {
        if (currentBuzz.timestamp !== previousTimestamp && currentBuzz.user_id !== currentUser.id) {
          document.getElementById("buzz-sound").play();
        }
        lastBuzzTimestamp = currentBuzz.timestamp;
        status.textContent = `${currentBuzz.username} hat gebuzzert!`;
        buzzerBtn.disabled = true;
        if (currentUser.role === 'admin') {
          adminActions.classList.remove("hidden");
        }
      } else {
        lastBuzzTimestamp = null;
        status.textContent = "Niemand hat bisher gebuzzert.";
        buzzerBtn.disabled = false;
        adminActions.classList.add("hidden");
      }

      loadScores(); // Punktetabelle immer aktualisieren
    }

    buzzerBtn.addEventListener("click", async () => {
      const existing = await getActiveBuzz();
      if (existing) return;

      const insertObj = {
        user_id: currentUser.id,
        username: currentUser.name,
        timestamp: new Date().toISOString(),
        active: true
      };

      const { error } = await supabase.from("buzzer_state").insert(insertObj);
      if (!error) {
        document.getElementById("buzz-sound").play();
        refreshStatus();
      }
    });

    async function updateScore(userId, username, delta) {
      const { data: existing } = await supabase
        .from("scores")
        .select("*")
        .eq("user_id", userId)
        .single();

      if (existing) {
        await supabase.from("scores")
          .update({ points: existing.points + delta })
          .eq("user_id", userId);
      } else {
        await supabase.from("scores")
          .insert({ user_id: userId, username: username, points: delta });
      }
    }

    async function resetBuzzer() {
      await supabase.from("buzzer_state").delete().gt("timestamp", "1900-01-01");
      refreshStatus();
    }

    plusBtn.addEventListener("click", async () => {
      if (currentBuzz) {
        await updateScore(currentBuzz.user_id, currentBuzz.username, 1);
        const { data: score } = await supabase
          .from('scores')
          .select('points')
          .eq('user_id', currentBuzz.user_id)
          .single();
        if (activeRound && score && score.points >= activeRound.point_limit) {
          await endRound(currentBuzz.user_id, currentBuzz.username);
        }
        await resetBuzzer();
      }
    });

    minusBtn.addEventListener("click", async () => {
      if (currentBuzz) {
        await updateScore(currentBuzz.user_id, currentBuzz.username, -1);
        await resetBuzzer();
      }
    });

    passBtn.addEventListener("click", async () => {
      if (currentBuzz) {
        await resetBuzzer();
      }
    });

    resetScoresBtn.addEventListener("click", async () => {
      if (!confirm('Alle Punkte wirklich auf 0 setzen?')) return;
      const { error } = await adminClient
        .from('scores')
        .update({ points: 0 })
        .not('user_id', 'is', null); // Filter erforderlich, aktualisiert alle Einträge

      if (error) {
        console.error('Fehler beim Zurücksetzen der Punkte:', error.message);
        return;
      }

      loadScores();
    });

    let lastScoresJson = "";
    async function loadScores() {
      const { data, error } = await supabase
        .from("scores")
        .select("username, points")
        .order("username", { ascending: true });

      if (error) {
        console.error("Fehler beim Laden der Punkte:", error.message);
        return;
      }

      const newJson = JSON.stringify(data);
      if (newJson === lastScoresJson) return;
      lastScoresJson = newJson;

      const tbody = document.getElementById("scoreboard-body");
      const fragment = document.createDocumentFragment();
      for (const row of data) {
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td class="px-2 py-1 border-b">${row.username}</td>
          <td class="px-2 py-1 border-b text-right font-semibold">${row.points}</td>
        `;
        fragment.appendChild(tr);
      }
      tbody.replaceChildren(fragment);
    }

    async function loadParticipants() {
      if (!activeRound) return;
      const { data, error } = await supabase
        .from('buzzer_participants')
        .select('username')
        .eq('round_id', activeRound.id)
        .order('username', { ascending: true });
      if (error) {
        console.error('Fehler beim Laden der Teilnehmer:', error.message);
        return;
      }
      const names = (data || []).map(p => p.username).join(', ');
      participantList.textContent = names ? `Angemeldet: ${names}` : 'Noch keine Anmeldungen';
    }

    function updateSignupTimer() {
      if (!activeRound) return;
      const end = parseTime(activeRound.start_time).getTime() + 120000;
      const diff = Math.max(0, Math.floor((end - Date.now()) / 1000));
      signupTimer.textContent = `Anmeldephase: ${diff}s`;
      loadParticipants();
      if (diff <= 0) {
        signupContainer.classList.add('hidden');
        roundInfo.classList.add('hidden');
        clearInterval(registrationInterval);
      }
    }

    function updateRoundUI() {
      if (!activeRound && lastResult) {
        resultDisplay.classList.remove('hidden');
        winnerNameEl.textContent = `Gewinner: ${lastResult.winnerName}`;
        prizeInfoEl.textContent = `Gewinn: ${lastResult.prize.toFixed(2)} €`;
      } else {
        resultDisplay.classList.add('hidden');
      }
      if (currentUser?.role === 'admin' && (!activeRound || !activeRound.active)) {
        roundControls.classList.remove('hidden');
      } else {
        roundControls.classList.add('hidden');
      }

      const inRegistration = activeRound && activeRound.active &&
        Date.now() - parseTime(activeRound.start_time).getTime() < 120000;

      if (inRegistration) {
        roundInfo.classList.remove('hidden');
        betInfo.textContent = `Einsatz: ${activeRound.bet.toFixed(2)} €`;
        updateSignupTimer();
        if (!registrationInterval) {
          registrationInterval = setInterval(updateSignupTimer, 1000);
        }
      } else {
        roundInfo.classList.add('hidden');
        betInfo.textContent = '';
        clearInterval(registrationInterval);
        registrationInterval = null;
      }

      if (inRegistration && !signedUp) {
        signupContainer.classList.remove('hidden');
      } else {
        signupContainer.classList.add('hidden');
      }
    }

    async function loadActiveRound() {
      const { data: active } = await supabase
        .from('buzzer_rounds')
        .select('*')
        .eq('active', true)
        .order('start_time', { ascending: false })
        .limit(1)
        .single();
      activeRound = active || null;
      if (activeRound) {
        const { data: existing } = await supabase
          .from('buzzer_participants')
          .select('id')
          .eq('round_id', activeRound.id)
          .eq('user_id', currentUser.id)
          .maybeSingle();
        signedUp = !!existing;
        await loadParticipants();
        lastResult = null;
      } else {
        signedUp = false;
        participantList.textContent = '';
        const { data: lastRound } = await supabase
          .from('buzzer_rounds')
          .select('id, bet, winner_id, active')
          .order('start_time', { ascending: false })
          .limit(1)
          .single();
        if (lastRound && !lastRound.active && lastRound.winner_id) {
          const { data: winner } = await supabase
            .from('users')
            .select('name')
            .eq('id', lastRound.winner_id)
            .single();
          const { data: parts } = await supabase
            .from('buzzer_participants')
            .select('id')
            .eq('round_id', lastRound.id);
          const prize = (parts?.length || 0) * lastRound.bet;
          lastResult = { roundId: lastRound.id, winnerName: winner?.name || '', prize };
        } else {
          lastResult = null;
        }
      }
      updateRoundUI();
    }

    async function startRound(bet, limit) {
      clearInterval(registrationInterval);
      registrationInterval = null;
      signupTimer.textContent = '';

      try {
        const { data, error } = await adminClient
          .from('buzzer_rounds')
          .insert({ bet, point_limit: limit, start_time: new Date().toISOString(), active: true })
          .select()
          .single();

        if (error) {
          const msg = error.message || error.details || error.hint || error.code || 'Unbekannter Fehler';
          console.error('Fehler beim Starten der Runde:', error);
          alert(`Fehler beim Starten der Runde: ${msg}`);
          return;
        }

        await adminClient.from('scores').update({ points: 0 }).not('user_id', 'is', null);
        activeRound = data;
        signedUp = false;
        startRoundModal.classList.add('hidden');
        await loadParticipants();
        updateRoundUI();
      } catch (err) {
        const msg = err.message || 'Unbekannter Fehler';
        console.error('Fehler beim Starten der Runde:', err);
        alert(`Fehler beim Starten der Runde: ${msg}`);
      }
    }

    async function signupForRound() {
      if (!activeRound || signedUp) return;
      signupBtn.disabled = true;
      const bet = activeRound.bet;
      const { data: user } = await supabase.from('users').select('balance').eq('id', currentUser.id).single();
      await supabase.from('users').update({ balance: user.balance - bet }).eq('id', currentUser.id);
      await supabase.from('buzzer_participants').insert({ round_id: activeRound.id, user_id: currentUser.id, username: currentUser.name });
      await updateScore(currentUser.id, currentUser.name, 0);
      signedUp = true;
      signupContainer.classList.add('hidden');
      await loadParticipants();
    }

   async function endRound(winnerId, winnerName) {
     if (!activeRound) return;
      clearInterval(registrationInterval);
      registrationInterval = null;
      const { data: participants } = await supabase
        .from('buzzer_participants')
        .select('user_id')
        .eq('round_id', activeRound.id);
      const total = (participants?.length || 0) * activeRound.bet;
      const { data: winner } = await supabase.from('users').select('balance').eq('id', winnerId).single();
      await supabase.from('users').update({ balance: winner.balance + total }).eq('id', winnerId);
      await adminClient.from('buzzer_rounds').update({ active: false, winner_id: winnerId }).eq('id', activeRound.id);
      activeRound.active = false;
      const prize = total;
      lastResult = { roundId: activeRound.id, winnerName, prize };
      resultDisplay.classList.remove('hidden');
      winnerNameEl.textContent = `Gewinner: ${winnerName}`;
      prizeInfoEl.textContent = `Gewinn: ${prize.toFixed(2)} €`;
      const { data: balances } = await supabase.from('users')
        .select('name, balance')
        .in('id', participants.map(p => p.user_id));
      balanceList.innerHTML = (balances || []).map(b => `<div>${b.name}: ${b.balance.toFixed(2)} €</div>`).join('');
      participantList.textContent = '';
      updateRoundUI();
    }

    startRoundBtn?.addEventListener('click', () => {
      startRoundModal.classList.remove('hidden');
    });
    cancelRoundBtn?.addEventListener('click', () => {
      startRoundModal.classList.add('hidden');
    });
    confirmRoundBtn?.addEventListener('click', async () => {
      confirmRoundBtn.disabled = true;
      const bet = parseFloat(roundBet.value);
      const limit = parseInt(roundLimit.value, 10) || 1;
      await startRound(bet, limit);
      confirmRoundBtn.disabled = false;
    });
    signupBtn?.addEventListener('click', signupForRound);

    supabase.channel('buzzer-updates')
      .on('postgres_changes', { event: '*', schema: 'public', table: 'buzzer_state' }, () => refreshStatus())
      .subscribe();

    supabase.channel('user-session-updates')
      .on('postgres_changes', { event: '*', schema: 'public', table: 'user_sessions' }, () => showOnlineUsers())
      .subscribe();

    supabase.channel('scoreboard-updates')
      .on('postgres_changes', { event: '*', schema: 'public', table: 'scores' }, () => loadScores())
      .subscribe();

    supabase.channel('round-updates')
      .on('postgres_changes', { event: '*', schema: 'public', table: 'buzzer_rounds' }, () => loadActiveRound())
      .subscribe();

    supabase.channel('participant-updates')
      .on('postgres_changes', { event: '*', schema: 'public', table: 'buzzer_participants' }, () => loadParticipants())
      .subscribe();

    checkUser().then(() => {
      refreshStatus();
      markOnline();
      showOnlineUsers();
      loadActiveRound();
    });

    // Regelmässig den aktuellen Buzzer-Status abrufen, damit alle Spieler
    // sofort sehen, wer gebuzzert hat, auch wenn Realtime-Updates einmal
    // nicht funktionieren.
    setInterval(() => {
      refreshStatus();
      loadActiveRound();
    }, 1000);

    window.addEventListener("beforeunload", () => {
      markOffline();
    });

    setInterval(() => {
      if (currentUser) {
        markOnline();
        showOnlineUsers();
      }
    }, 60000);
  </script>
</body>
</html>
