<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Buzzer</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = { darkMode: 'class' };
  </script>
  <script src="https://unpkg.com/@supabase/supabase-js"></script>
  <style>
    input, select, textarea {
      background-color: white;
      color: black;
    }
    ::placeholder {
      color: #6b7280;
    }
    .dark input,
    .dark select,
    .dark textarea {
      background-color: #374151;
      color: white;
    }
    .dark ::placeholder {
      color: #9ca3af;
    }
  </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen bg-green-100 text-green-900 font-sans space-y-6 px-4 dark:bg-gray-900 dark:text-white">
  <div class="fixed bottom-4 right-4 z-50">
    <button onclick="toggleDarkMode()" class="bg-gray-300/75 dark:bg-gray-700/75 text-black dark:text-white p-2 rounded-full shadow opacity-70 hover:opacity-100 transition">
      üåô
    </button>
  </div>
  <h1 class="text-3xl font-bold mt-6 sm:mt-8">üîî Buzzer</h1>
  <audio id="buzz-sound" src="buzz.wav" preload="auto"></audio>

  <p id="status" class="text-xl font-semibold"></p>
  <p id="online-info" class="text-md font-medium"></p>

  <button id="buzzer-btn" class="hidden w-full sm:w-auto text-3xl sm:text-4xl px-8 sm:px-12 py-8 sm:py-10 bg-green-600 text-white rounded-full shadow-xl hover:bg-green-700 disabled:opacity-50 transition-all duration-300">
    üö® BUZZERN
  </button>

  <!-- Admin Actions -->
  <div id="admin-actions" class="hidden space-x-4 mt-6">
    <button id="plus-btn" class="bg-blue-600 text-white px-4 py-2 rounded shadow hover:bg-blue-700">+1 Punkt</button>
    <button id="minus-btn" class="bg-yellow-600 text-white px-4 py-2 rounded shadow hover:bg-yellow-700">-1 Punkt</button>
    <button id="pass-btn" class="bg-gray-600 text-white px-4 py-2 rounded shadow hover:bg-gray-700">Pass</button>
  </div>

  <!-- Rundensteuerung -->
  <div id="round-controls" class="hidden mt-4 text-center">
    <button id="start-round-btn" class="bg-purple-600 text-white px-4 py-2 rounded shadow hover:bg-purple-700">Neue Runde starten</button>
  </div>

  <!-- Anmelden -->
  <div id="signup-container" class="hidden mt-4 text-center space-y-2">
    <p id="bet-info" class="text-sm"></p>
    <button id="signup-btn" class="bg-green-600 text-white px-4 py-2 rounded shadow hover:bg-green-700">Anmelden</button>
  </div>

  <!-- Rundeninfo -->
  <div id="round-info" class="hidden mt-2 text-center space-y-1 text-sm">
    <p id="signup-timer"></p>
    <div id="participant-list" class="text-xs"></div>
  </div>

  <!-- Ergebnis -->
  <div id="result-display" class="hidden mt-6 bg-white dark:bg-gray-800 p-4 rounded shadow text-center space-y-2">
    <h3 class="text-lg font-bold">Runde beendet</h3>
    <p id="winner-name"></p>
    <p id="prize-info"></p>
    <div id="balance-list" class="text-sm space-y-1"></div>
  </div>

  <!-- Dialog Runde starten -->
  <div id="start-round-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
    <div class="bg-white dark:bg-gray-700 p-6 rounded shadow-lg space-y-4">
      <h3 class="text-lg font-bold">Neue Runde</h3>
      <label class="block">Einsatz:
        <select id="round-bet" class="border p-2 rounded w-full mt-1">
          <option value="0.25">0,25 ‚Ç¨</option>
          <option value="0.5">0,50 ‚Ç¨</option>
          <option value="0.75">0,75 ‚Ç¨</option>
          <option value="1">1,00 ‚Ç¨</option>
          <option value="1.25">1,25 ‚Ç¨</option>
          <option value="1.5">1,50 ‚Ç¨</option>
          <option value="1.75">1,75 ‚Ç¨</option>
          <option value="2">2,00 ‚Ç¨</option>
        </select>
      </label>
      <label class="block">Punktelimit:
        <input id="round-limit" type="number" min="1" value="5" class="border p-2 rounded w-full mt-1">
      </label>
      <div class="text-right space-x-2">
        <button id="cancel-round-btn" class="bg-gray-500 text-white px-3 py-1 rounded">Abbrechen</button>
        <button id="confirm-round-btn" class="bg-green-600 text-white px-3 py-1 rounded">Starten</button>
      </div>
    </div>
  </div>

  <!-- Rundenbest√§tigung -->
  <div id="confirm-round-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
    <div class="bg-white dark:bg-gray-700 p-6 rounded shadow-lg space-y-4 text-center">
      <p id="round-details" class="font-semibold"></p>
      <button id="ack-round-btn" class="bg-green-600 text-white px-4 py-2 rounded shadow hover:bg-green-700">Verstanden</button>
    </div>
  </div>

  <!-- Punktestand-Tabelle -->
  <div id="scoreboard" class="w-full max-w-xs sm:max-w-md mt-8 bg-white shadow rounded p-4 text-sm sm:text-base overflow-x-auto dark:bg-gray-800">
    <h2 class="text-lg sm:text-xl font-bold mb-4 text-center">üèÜ Punktestand</h2>
    <table class="w-full table-auto text-left">
      <thead>
        <tr>
          <th class="px-2 py-1 border-b">Name</th>
          <th class="px-2 py-1 border-b text-right">Punkte</th>
        </tr>
      </thead>
      <tbody id="scoreboard-body">
        <!-- Dynamisch bef√ºllt -->
      </tbody>
    </table>
  </div>

  <!-- Hinweis bei neuem Rundenstart -->
  <div id="round-start-msg" class="hidden mt-2 text-center font-semibold text-green-700"></div>

  <!-- Spielstart nur f√ºr Admin -->
  <div id="start-game-container" class="hidden mt-4 text-center">
    <button id="start-game-btn" class="bg-green-600 text-white px-4 py-2 rounded shadow hover:bg-green-700">Spiel starten</button>
  </div>

  <!-- Spielverlauf -->
  <div id="history" class="w-full max-w-xs sm:max-w-md mt-8 bg-white shadow rounded p-4 text-sm sm:text-base overflow-x-auto dark:bg-gray-800">
    <h2 class="text-lg sm:text-xl font-bold mb-4 text-center">üìú Spielverlauf</h2>
    <div id="history-body" class="space-y-4"></div>
  </div>

  <div class="text-center mt-8 mb-8">
    <a href="dashboard.html" class="inline-block bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-full shadow">
      ‚¨ÖÔ∏è Zur√ºck zum Dashboard
    </a>
  </div>

  <script>
    function toggleDarkMode() {
      const isDark = document.documentElement.classList.toggle('dark');
      localStorage.setItem('darkMode', isDark ? 'true' : 'false');
    }
    if (localStorage.getItem('darkMode') === 'true') {
      document.documentElement.classList.add('dark');
    }

    const SUPABASE_URL = 'https://izkuiqjhzeeirmcikbef.supabase.co';
    const ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Iml6a3VpcWpoemVlaXJtY2lrYmVmIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDg4MDAwOTQsImV4cCI6MjA2NDM3NjA5NH0.mPu0jQYnt0uGoLgehNFDHZprEcmrzGJ667D31sLSbj0';
    const SERVICE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Iml6a3VpcWpoemVlaXJtY2lrYmVmIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc0ODgwMDA5NCwiZXhwIjoyMDY0Mzc2MDk0fQ.yF2-AKGKcHFNpkIt-bg-YMhWjjLK74cLw6t3VfjDl8w';

    const supabase = window.supabase.createClient(SUPABASE_URL, ANON_KEY);
    const adminClient = window.supabase.createClient(SUPABASE_URL, SERVICE_KEY);

    const buzzerBtn = document.getElementById("buzzer-btn");
    const status = document.getElementById("status");
    const onlineInfo = document.getElementById("online-info");
    const adminActions = document.getElementById("admin-actions");
    const plusBtn = document.getElementById("plus-btn");
    const minusBtn = document.getElementById("minus-btn");
    const passBtn = document.getElementById("pass-btn");
    const roundStartMsg = document.getElementById("round-start-msg");
    const confirmRoundModal = document.getElementById("confirm-round-modal");
    const roundDetails = document.getElementById("round-details");
    const ackRoundBtn = document.getElementById("ack-round-btn");
    const startGameContainer = document.getElementById("start-game-container");
    const startGameBtn = document.getElementById("start-game-btn");
    const roundControls = document.getElementById("round-controls");
    const startRoundBtn = document.getElementById("start-round-btn");
    const signupContainer = document.getElementById("signup-container");
    const betInfo = document.getElementById("bet-info");
    const signupBtn = document.getElementById("signup-btn");
    const roundInfo = document.getElementById("round-info");
    const signupTimer = document.getElementById("signup-timer");
    const participantList = document.getElementById("participant-list");
    const resultDisplay = document.getElementById("result-display");
    const winnerNameEl = document.getElementById("winner-name");
    const prizeInfoEl = document.getElementById("prize-info");
    const balanceList = document.getElementById("balance-list");
    const startRoundModal = document.getElementById("start-round-modal");
    const roundBet = document.getElementById("round-bet");
    const roundLimit = document.getElementById("round-limit");
    const cancelRoundBtn = document.getElementById("cancel-round-btn");
    const confirmRoundBtn = document.getElementById("confirm-round-btn");

    function parseTime(ts) {
      return new Date(ts.endsWith('Z') ? ts : ts + 'Z');
    }

    let activeRound = null;
    let registrationInterval = null;
    let signedUp = false;
    let lastResult = null;

    let currentUser = null;
    let currentBuzz = null;
    let lastBuzzTimestamp = null;

    async function checkUser() {
      const { data: auth, error } = await supabase.auth.getUser();
      if (error || !auth?.user) {
        return location.href = "index.html";
      }
      currentUser = auth.user;

      const { data: profile } = await supabase
        .from("users")
        .select("role, name")
        .eq("id", currentUser.id)
        .single();

      if (!profile) return;

      currentUser.name = profile.name;
      currentUser.role = profile.role;

      if (currentUser.role === 'admin') {
        roundControls.classList.remove('hidden');
      }
    }

    async function markOnline() {
      const now = new Date().toISOString();
      await supabase.from("user_sessions").upsert({
        user_id: currentUser.id,
        username: currentUser.name,
        last_active: now,
        online: true
      }, { onConflict: ["user_id"] });
    }

    async function markOffline() {
      await supabase.from("user_sessions")
        .update({ online: false })
        .eq("user_id", currentUser.id);
    }

    async function showOnlineUsers() {
      const threshold = new Date(Date.now() - 2 * 60 * 1000).toISOString();
      const { data, error } = await supabase
        .from("user_sessions")
        .select("username, last_active")
        .eq("online", true)
        .gt("last_active", threshold);

      if (!error) {
        const active = data || [];
        const count = active.length;
        const names = active.map(u => u.username).join(", ");
        onlineInfo.textContent = `üü¢ Online (${count}): ${names}`;
      }
    }

    async function getActiveBuzz() {
      const { data, error } = await supabase
        .from("buzzer_state")
        .select("*")
        .eq("active", true)
        .order("timestamp", { ascending: true })
        .limit(1)
        .single();

      return error ? null : data;
    }

    async function refreshStatus() {
      const previousTimestamp = lastBuzzTimestamp;
      currentBuzz = await getActiveBuzz();

      if (currentBuzz) {
        if (currentBuzz.timestamp !== previousTimestamp && currentBuzz.user_id !== currentUser.id) {
          document.getElementById("buzz-sound").play();
        }
        lastBuzzTimestamp = currentBuzz.timestamp;
        status.textContent = `${currentBuzz.username} hat gebuzzert!`;
        buzzerBtn.disabled = true;
        if (currentUser.role === 'admin') {
          adminActions.classList.remove("hidden");
        }
      } else {
        lastBuzzTimestamp = null;
        status.textContent = "Niemand hat bisher gebuzzert.";
        buzzerBtn.disabled = false;
        adminActions.classList.add("hidden");
      }

      loadScores(); // Punktetabelle immer aktualisieren
    }

    buzzerBtn.addEventListener("click", async () => {
      const existing = await getActiveBuzz();
      if (existing) return;

      const insertObj = {
        user_id: currentUser.id,
        username: currentUser.name,
        timestamp: new Date().toISOString(),
        active: true
      };

      const { error } = await supabase.from("buzzer_state").insert(insertObj);
      if (!error) {
        document.getElementById("buzz-sound").play();
        refreshStatus();
      }
    });

    async function updateScore(userId, username, delta) {
      const { data: existing } = await supabase
        .from("scores")
        .select("*")
        .eq("user_id", userId)
        .single();

      if (existing) {
        await supabase.from("scores")
          .update({ points: existing.points + delta })
          .eq("user_id", userId);
      } else {
        await supabase.from("scores")
          .insert({ user_id: userId, username: username, points: delta });
      }
    }

    async function resetBuzzer() {
      await supabase.from("buzzer_state").delete().gt("timestamp", "1900-01-01");
      refreshStatus();
    }

    plusBtn.addEventListener("click", async () => {
      if (currentBuzz) {
        await updateScore(currentBuzz.user_id, currentBuzz.username, 1);
        const { data: score } = await supabase
          .from('scores')
          .select('points')
          .eq('user_id', currentBuzz.user_id)
          .single();
        if (activeRound && score && score.points >= activeRound.point_limit) {
          await endRound(currentBuzz.user_id, currentBuzz.username);
        }
        await resetBuzzer();
      }
    });

    minusBtn.addEventListener("click", async () => {
      if (currentBuzz) {
        await updateScore(currentBuzz.user_id, currentBuzz.username, -1);
        await resetBuzzer();
      }
    });

    passBtn.addEventListener("click", async () => {
      if (currentBuzz) {
        await resetBuzzer();
      }
    });


    let lastScoresJson = "";
    async function loadScores() {
      if (!activeRound) {
        document.getElementById("scoreboard-body").innerHTML = "";
        return;
      }

      const { data: participants, error: pErr } = await supabase
        .from('buzzer_participants')
        .select('user_id, username')
        .eq('round_id', activeRound.id);

      if (pErr) {
        console.error('Fehler beim Laden der Teilnehmer:', pErr.message);
        return;
      }

      const ids = participants.map(p => p.user_id);
      const { data: scores, error } = await supabase
        .from('scores')
        .select('user_id, points')
        .in('user_id', ids);

      if (error) {
        console.error('Fehler beim Laden der Punkte:', error.message);
        return;
      }

      const scoreMap = {};
      for (const s of scores || []) scoreMap[s.user_id] = s.points;

      const rows = participants
        .sort((a,b) => a.username.localeCompare(b.username))
        .map(p => ({ name: p.username, points: scoreMap[p.user_id] || 0 }));

      const newJson = JSON.stringify(rows);
      if (newJson === lastScoresJson) return;
      lastScoresJson = newJson;

      const tbody = document.getElementById("scoreboard-body");
      const fragment = document.createDocumentFragment();
      for (const row of rows) {
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td class="px-2 py-1 border-b">${row.name}</td>
          <td class="px-2 py-1 border-b text-right font-semibold">${row.points}</td>
        `;
        fragment.appendChild(tr);
      }
      tbody.replaceChildren(fragment);
    }

    async function loadParticipants() {
      if (!activeRound) return;
      const { data, error } = await supabase
        .from('buzzer_participants')
        .select('username')
        .eq('round_id', activeRound.id)
        .order('username', { ascending: true });
      if (error) {
        console.error('Fehler beim Laden der Teilnehmer:', error.message);
        return;
      }
      const names = (data || []).map(p => p.username).join(', ');
      participantList.textContent = names ? `Angemeldet: ${names}` : 'Noch keine Anmeldungen';
    }

    async function loadHistory() {
      const { data: rounds, error } = await supabase
        .from('buzzer_rounds')
        .select('id, bet, winner_id, start_time')
        .order('start_time', { ascending: false })
        .limit(10);
      if (error) {
        console.error('Fehler beim Laden des Verlaufs:', error.message);
        return;
      }

      const container = document.getElementById('history-body');
      const fragment = document.createDocumentFragment();

      for (const r of rounds || []) {
        const { data: parts } = await supabase
          .from('buzzer_participants')
          .select('user_id, username')
          .eq('round_id', r.id);

        const pot = (parts?.length || 0) * r.bet;
        const entry = document.createElement('div');
        entry.className = 'border-b pb-2 mb-2';

        const winner = parts?.find(p => p.user_id === r.winner_id);
        let html = `<div class="font-semibold">${new Date(r.start_time).toLocaleString('de-DE', { timeZone: 'Europe/Berlin' })} ‚Äì Gewinner: ${winner ? winner.username : '-'} (${pot.toFixed(2)} ‚Ç¨)</div>`;
        html += '<ul class="ml-4 list-disc">';
        for (const p of parts || []) {
          const delta = p.user_id === r.winner_id ? pot - r.bet : -r.bet;
          const sign = delta > 0 ? '+' : '';
          html += `<li>${p.username}: ${sign}${delta.toFixed(2)} ‚Ç¨</li>`;
        }
        html += '</ul>';
        entry.innerHTML = html;
        fragment.appendChild(entry);
      }

      container.replaceChildren(fragment);
    }

    function updateRoundUI() {
      signupContainer.classList.add('hidden');
      roundInfo.classList.add('hidden');
      if (!activeRound && lastResult) {
        resultDisplay.classList.remove('hidden');
        winnerNameEl.textContent = `Gewinner: ${lastResult.winnerName}`;
        prizeInfoEl.textContent = `Gewinn: ${lastResult.prize.toFixed(2)} ‚Ç¨`;
      } else {
        resultDisplay.classList.add('hidden');
      }
      if (currentUser?.role === 'admin' && !activeRound) {
        roundControls.classList.remove('hidden');
      } else {
        roundControls.classList.add('hidden');
      }

      if (activeRound && activeRound.active) {
        buzzerBtn.classList.remove('hidden');
      } else {
        buzzerBtn.classList.add('hidden');
      }
    }

    async function loadActiveRound() {
      const { data: latest } = await supabase
        .from('buzzer_rounds')
        .select('*')
        .order('start_time', { ascending: false })
        .limit(1)
        .single();
      activeRound = latest || null;
      if (activeRound) {
        const { data: existing } = await supabase
          .from('buzzer_participants')
          .select('id')
          .eq('round_id', activeRound.id)
          .eq('user_id', currentUser.id)
          .maybeSingle();
        signedUp = !!existing;
        await loadParticipants();
        await loadConfirmations();
        lastResult = null;
      } else {
        signedUp = false;
        participantList.textContent = '';
        const { data: lastRound } = await supabase
          .from('buzzer_rounds')
          .select('id, bet, winner_id, active')
          .order('start_time', { ascending: false })
          .limit(1)
          .single();
        if (lastRound && !lastRound.active && lastRound.winner_id) {
          const { data: winner } = await supabase
            .from('users')
            .select('name')
            .eq('id', lastRound.winner_id)
            .single();
          const { data: parts } = await supabase
            .from('buzzer_participants')
            .select('id')
            .eq('round_id', lastRound.id);
          const prize = (parts?.length || 0) * lastRound.bet;
          lastResult = { roundId: lastRound.id, winnerName: winner?.name || '', prize };
        } else {
          lastResult = null;
        }
      }
      updateRoundUI();
    }

    async function startRound(bet, limit) {
      try {
        await adminClient.from('scores').update({ points: 0 }).not('user_id', 'is', null);
        await adminClient.from('buzzer_state').delete().gt('timestamp', '1900-01-01');
        await adminClient.from('buzzer_participants').delete().gt('id', 0);
        await adminClient.from('round_confirmations').delete().neq('round_id', null);

        const { data, error } = await adminClient
          .from('buzzer_rounds')
          .insert({ bet, point_limit: limit, start_time: new Date().toISOString(), active: false })
          .select()
          .single();

        if (error) {
          const msg = error.message || error.details || error.hint || error.code || 'Unbekannter Fehler';
          console.error('Fehler beim Starten der Runde:', error);
          alert(`Fehler beim Starten der Runde: ${msg}`);
          return;
        }

        activeRound = data;
        startRoundModal.classList.add('hidden');
        roundDetails.textContent = `Einsatz: ${bet.toFixed(2)} ‚Ç¨ ‚Äì Gewinn: ${(bet * 7).toFixed(2)} ‚Ç¨ ‚Äì Spielziel: ${limit} Punkte`;
        confirmRoundModal.classList.remove('hidden');
        roundStartMsg.textContent = 'Neue Runde gestartet';
        roundStartMsg.classList.remove('hidden');
        setTimeout(() => roundStartMsg.classList.add('hidden'), 3000);
        loadConfirmations();
        updateRoundUI();
      } catch (err) {
        const msg = err.message || 'Unbekannter Fehler';
        console.error('Fehler beim Starten der Runde:', err);
        alert(`Fehler beim Starten der Runde: ${msg}`);
      }
    }

    async function signupForRound() {
      if (!activeRound || signedUp) return;
      signupBtn.disabled = true;
      const bet = activeRound.bet;
      const { data: user } = await supabase.from('users').select('balance').eq('id', currentUser.id).single();
      await supabase.from('users').update({ balance: user.balance - bet }).eq('id', currentUser.id);
      await supabase.from('buzzer_participants').insert({ round_id: activeRound.id, user_id: currentUser.id, username: currentUser.name });
      await updateScore(currentUser.id, currentUser.name, 0);
      signedUp = true;
      signupContainer.classList.add('hidden');
      await loadParticipants();
    }

    async function loadConfirmations() {
      if (!activeRound) return;
      const { data: confs } = await supabase
        .from('round_confirmations')
        .select('user_id')
        .eq('round_id', activeRound.id);
      const confirmed = (confs || []).map(c => c.user_id);
      const { data: online } = await supabase
        .from('user_sessions')
        .select('user_id')
        .eq('online', true);
      const onlineIds = (online || []).map(o => o.user_id);
      const allReady = onlineIds.every(id => confirmed.includes(id));
      if (!confirmed.includes(currentUser.id)) {
        confirmRoundModal.classList.remove('hidden');
      } else {
        confirmRoundModal.classList.add('hidden');
      }
      if (allReady && currentUser.role === 'admin') {
        startGameContainer.classList.remove('hidden');
      } else {
        startGameContainer.classList.add('hidden');
      }
    }

    async function acknowledgeRound() {
      if (!activeRound) return;
      ackRoundBtn.disabled = true;
      await supabase.from('round_confirmations')
        .upsert({ round_id: activeRound.id, user_id: currentUser.id });
      ackRoundBtn.disabled = false;
      confirmRoundModal.classList.add('hidden');
    }

    async function startGame() {
      if (!activeRound) return;
      startGameBtn.disabled = true;
      await adminClient.from('buzzer_rounds')
        .update({ active: true })
        .eq('id', activeRound.id);
      activeRound.active = true;
      startGameContainer.classList.add('hidden');
      updateRoundUI();
      startGameBtn.disabled = false;
    }

   async function endRound(winnerId, winnerName) {
     if (!activeRound) return;
      clearInterval(registrationInterval);
      registrationInterval = null;
      const { data: participants } = await supabase
        .from('buzzer_participants')
        .select('user_id')
        .eq('round_id', activeRound.id);
      const total = (participants?.length || 0) * activeRound.bet;
      const { data: winner } = await supabase.from('users').select('balance').eq('id', winnerId).single();
      await supabase.from('users').update({ balance: winner.balance + total }).eq('id', winnerId);
      await adminClient.from('buzzer_rounds').update({ active: false, winner_id: winnerId }).eq('id', activeRound.id);
      activeRound.active = false;
      const prize = total;
      lastResult = { roundId: activeRound.id, winnerName, prize };
      resultDisplay.classList.remove('hidden');
      winnerNameEl.textContent = `Gewinner: ${winnerName}`;
      prizeInfoEl.textContent = `Gewinn: ${prize.toFixed(2)} ‚Ç¨`;
      const { data: balances } = await supabase.from('users')
        .select('name, balance')
        .in('id', participants.map(p => p.user_id));
      balanceList.innerHTML = (balances || []).map(b => `<div>${b.name}: ${b.balance.toFixed(2)} ‚Ç¨</div>`).join('');
      participantList.textContent = '';
      updateRoundUI();
    }

    startRoundBtn?.addEventListener('click', () => {
      startRoundModal.classList.remove('hidden');
    });
    cancelRoundBtn?.addEventListener('click', () => {
      startRoundModal.classList.add('hidden');
    });
    confirmRoundBtn?.addEventListener('click', async () => {
      confirmRoundBtn.disabled = true;
      const bet = parseFloat(roundBet.value);
      const limit = parseInt(roundLimit.value, 10) || 1;
      await startRound(bet, limit);
      confirmRoundBtn.disabled = false;
    });
    ackRoundBtn?.addEventListener('click', acknowledgeRound);
    startGameBtn?.addEventListener('click', startGame);

    supabase.channel('buzzer-updates')
      .on('postgres_changes', { event: '*', schema: 'public', table: 'buzzer_state' }, () => refreshStatus())
      .subscribe();

    supabase.channel('user-session-updates')
      .on('postgres_changes', { event: '*', schema: 'public', table: 'user_sessions' }, () => showOnlineUsers())
      .subscribe();

    supabase.channel('scoreboard-updates')
      .on('postgres_changes', { event: '*', schema: 'public', table: 'scores' }, () => loadScores())
      .subscribe();

    supabase.channel('round-updates')
      .on('postgres_changes', { event: '*', schema: 'public', table: 'buzzer_rounds' }, () => { loadActiveRound(); loadHistory(); })
      .subscribe();

    supabase.channel('participant-updates')
      .on('postgres_changes', { event: '*', schema: 'public', table: 'buzzer_participants' }, () => loadParticipants())
      .subscribe();

    supabase.channel('confirmation-updates')
      .on('postgres_changes', { event: '*', schema: 'public', table: 'round_confirmations' }, () => loadConfirmations())
      .subscribe();

    checkUser().then(() => {
      refreshStatus();
      markOnline();
      showOnlineUsers();
      loadActiveRound();
      loadHistory();
    });

    // Regelm√§ssig den aktuellen Buzzer-Status abrufen, damit alle Spieler
    // sofort sehen, wer gebuzzert hat, auch wenn Realtime-Updates einmal
    // nicht funktionieren.
    setInterval(() => {
      refreshStatus();
      loadActiveRound();
    }, 1000);

    window.addEventListener("beforeunload", () => {
      markOffline();
    });

    setInterval(() => {
      if (currentUser) {
        markOnline();
        showOnlineUsers();
      }
    }, 60000);
  </script>
</body>
</html>
